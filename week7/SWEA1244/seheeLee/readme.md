## 풀이

이 문제는 제일 많은 상금을 구하는 것이 목표이다. 하지만, 단순히 생각하면 안되는 것이 최대 상금이 되더라도 교환 횟수가 남아있다면 무조건 자리를 교환해야한다.

위 문제를 해결하기 위해서 모든 경우를 탐색해봐야 최대 값인지 알 수 있다. 모든 경우를 탐색하기 위해서 재귀 DFS를 사용했다.

만약 아래와 같이 예시가 있을 때,

// 1 2 3 4 5

1회 교환할 수 있는 경우는

12 13 14 15

23 24 25

34 35

45

이다.

따라서, 변경 해보고 (변경 횟수를 +1) 하여 재귀로 전달한다. 그런 다음 다음 경우와 독립 시행해보기 위해서 다시 돌린다.

```
t = arr[i]; arr[i] = arr[j]; arr[j] = t; //자리를 바꾼다.
                dfs(i, cnt+1);  //바꿨을 경우로 다시 돌려본다.
                t = arr[i]; arr[i] = arr[j]; arr[j] = t;
```

이렇게하면 모든 경우를 탐색하여 경우를 따질 수 있다. if 문을 설정하여 완성이 될 때 마다. MAX 비교하여 값을 저장하고 출력하여 해결할 수 있다.
